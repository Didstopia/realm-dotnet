<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Realm</name>
    </assembly>
    <members>
        <member name="T:Realms.InteropConfig">
             <summary>
             Per-platform utility functions. A copy of this file exists in each platform project such as Realm.Win32.
             </summary>
            </member>
        <member name="T:Realms.RealmDecryptionFailedException">
             <summary>
             An exception, raised when file decryption is unsuccessful, most likely due to invalid EncryptionKey.
             </summary>
            </member>
        <member name="T:Realms.RealmObjectManagedByAnotherRealmException">
             <summary>
             Exception thrown when you're trying to use Add but the object is already managed by a different Realm.
             </summary>
            </member>
        <member name="T:Realms.RealmFileExistsException">
             <summary>
             Exception thrown when a file exists with the same name as you to create a new one.
             </summary>
            </member>
        <member name="T:Realms.RealmInvalidDatabaseException">
             <summary>
             Exception thrown when a file exists but doesn't appear to be a Realm database, may indicate corruption.
             </summary>
            </member>
        <member name="T:Realms.RealmPermissionDeniedException">
             <summary>
             Exception when you can't open an existing realm file, or create a new one.
             </summary>
             <remarks>
             May be seen in testing if you have crashed a unit test but an external test runner is still going.
             </remarks>
            </member>
        <member name="M:Realms.QueryHandle.StringContains(System.IntPtr,System.String,System.Boolean)">
             <summary>
             If the user hasn't specified it, should be caseSensitive=true.
             </summary>
            </member>
        <member name="M:Realms.QueryHandle.StringStartsWith(System.IntPtr,System.String,System.Boolean)">
             <summary>
             If the user hasn't specified it, should be <c>caseSensitive = true</c>.
             </summary>
            </member>
        <member name="M:Realms.QueryHandle.StringEndsWith(System.IntPtr,System.String,System.Boolean)">
             <summary>
             If the user hasn't specified it, should be <c>caseSensitive = true</c>.
             </summary>
            </member>
        <member name="M:Realms.QueryHandle.StringEqual(System.IntPtr,System.String,System.Boolean)">
             <summary>
             If the user hasn't specified it, should be <c>caseSensitive = true</c>.
             </summary>
            </member>
        <member name="M:Realms.QueryHandle.StringNotEqual(System.IntPtr,System.String,System.Boolean)">
             <summary>
             If the user hasn't specified it, should be <c>caseSensitive = true</c>.
             </summary>
            </member>
        <member name="M:Realms.RealmHandle.Unbind">
             <summary>
             Override Unbind and put in code that actually calls core and unbinds whatever this handle is about.
             when this is called, it has already been verified that it is safe to call core - so just put in code that does the job.
             </summary>
            </member>
        <member name="M:Realms.RealmHandle.RequestUnbind(Realms.RealmHandle)">
             <summary>
             Called by children to this root, when they would like to 
             be unbound, but are (possibly) running in a finalizer thread 
             so it is (possibly) not safe to unbind then directly.
             </summary>
             <param name="handleToUnbind">The core handle that is not needed anymore and should be unbound.</param>
            </member>
        <member name="T:Realms.ChangeSet">
             <summary>
             A <see cref="T:Realms.ChangeSet" /> describes the changes inside a <see cref="T:Realms.IRealmCollection`1" /> since the last time the notification callback was invoked.
             </summary>
            </member>
        <member name="P:Realms.ChangeSet.InsertedIndices">
             <summary>
             Gets the indices in the new version of the <see cref="T:Realms.IRealmCollection`1" /> which were newly inserted.
             </summary>
            </member>
        <member name="P:Realms.ChangeSet.ModifiedIndices">
             <summary>
             Gets the indices in the new version of the <see cref="T:Realms.IRealmCollection`1" /> which were modified. This means that the property of an object at that index was modified
             or the property of another object it's related to.
             </summary>
            </member>
        <member name="P:Realms.ChangeSet.DeletedIndices">
             <summary>
             Gets the indices of objects in the previous version of the <see cref="T:Realms.IRealmCollection`1" /> which have been removed from this one.
             </summary>
            </member>
        <member name="P:Realms.ChangeSet.Moves">
             <summary>
             Gets the rows in the collection which moved.
             </summary>
             <remarks>
             Every <c>From</c> index will be present in <c>DeletedIndices</c> and every <c>To</c> index will be present in <c>InsertedIndices</c>.
             </remarks>
            </member>
        <member name="T:Realms.ChangeSet.Move">
             <summary>
             A <see cref="T:Realms.ChangeSet.Move" /> contains information about objects that moved within the same <see cref="T:Realms.IRealmCollection`1" />.
             </summary>
            </member>
        <member name="P:Realms.ChangeSet.Move.From">
             <summary>
             Gets the index in the old version of the <see cref="T:Realms.IRealmCollection`1" /> from which the object has moved.
             </summary>
            </member>
        <member name="P:Realms.ChangeSet.Move.To">
             <summary>
             Gets the index in the new version of the <see cref="T:Realms.IRealmCollection`1" /> to which the object has moved.
             </summary>
            </member>
        <member name="T:Realms.NotificationCallbackDelegate`1">
             <summary>
             A callback that will be invoked each time the contents of a <see cref="T:Realms.IRealmCollection`1" /> have changed.
             </summary>
             <param name="sender">The <see cref="T:Realms.IRealmCollection`1" /> being monitored for changes.</param>
             <param name="changes">The <see cref="T:Realms.ChangeSet" /> describing the changes to a <see cref="T:Realms.IRealmCollection`1" />, or <c>null</c> if an error occurred.</param>
             <param name="error">An exception that might have occurred while asynchronously monitoring a <see cref="T:Realms.IRealmCollection`1" /> for changes, or <c>null</c> if no errors occurred.</param>
             <typeparam name="T">Type of the RealmObject which is being returned.</typeparam>
            </member>
        <member name="T:Realms.IRealmCollection`1">
             <summary>
             Iterable, sortable collection of one kind of RealmObject resulting from <see cref="M:Realms.Realm.All(System.String)" /> or from a LINQ query expression.
             </summary>
             <typeparam name="T">Type of the RealmObject which is being returned.</typeparam>
            </member>
        <member name="P:Realms.IRealmCollection`1.ObjectSchema">
             <summary>
             Gets the object schema of the contained objects.
             </summary>
            </member>
        <member name="M:Realms.IRealmCollection`1.SubscribeForNotifications(Realms.NotificationCallbackDelegate{`0})">
             <summary>
             Register a callback to be invoked each time this <see cref="T:Realms.IRealmCollection`1" /> changes.
             </summary>
             <remarks>
             <para>
             The callback will be asynchronously invoked with the initial <see cref="T:Realms.IRealmCollection`1" />, and then called again after each write transaction
             which changes either any of the objects in the collection, or which objects are in the collection.
             The <c>changes</c> parameter will be <c>null</c> the first time the callback is invoked with the initial results.
             For each call after that, it will contain information about which rows in the results were added, removed or modified.
             </para>
             <para>
             If a write transaction did not modify any objects in this <see cref="T:Realms.IRealmCollection`1" />, the callback is not invoked at all.
             If an error occurs the callback will be invoked with <c>null</c> for the <c>sender</c> parameter and a non-<c>null</c> <c>error</c>.
             Currently the only errors that can occur are when opening the <see cref="T:Realms.Realm" /> on the background worker thread.
             </para>
             <para>
             At the time when the block is called, the <see cref="T:Realms.IRealmCollection`1" /> object will be fully evaluated and up-to-date, and as long as you do not perform a write transaction on the same thread
             or explicitly call <see cref="M:Realms.Realm.Refresh" />, accessing it will never perform blocking work.
             </para>
             <para>
             Notifications are delivered via the standard event loop, and so can't be delivered while the event loop is blocked by other activity.
             When notifications can't be delivered instantly, multiple notifications may be coalesced into a single notification.
             This can include the notification with the initial collection.
             </para>
             </remarks>
             <param name="callback">The callback to be invoked with the updated <see cref="T:Realms.IRealmCollection`1" />.</param>
             <returns>
             A subscription token. It must be kept alive for as long as you want to receive change notifications.
             To stop receiving notifications, call <see cref="M:System.IDisposable.Dispose" />.
             </returns>
            </member>
        <member name="M:Realms.Native.SortDescriptorBuilder.Flatten">
             <summary>
             Create a flattened array of all the clauses by concatenating the lists.
             </summary>
             <returns>
             A tuple with two elements. Item1 is the concatenated list of indices. Item2 is the list of clauses,
             indicating the offset and count, as well as the ascending flag for each clause.
             </returns>
            </member>
        <member name="T:Realms.Realm">
             <summary>
             A Realm instance (also referred to as a realm) represents a Realm database.
             </summary>
             <remarks>Warning: Realm instances are not thread safe and can not be shared across threads 
             You must call GetInstance on each thread in which you want to interact with the realm. 
             </remarks>
            </member>
        <member name="M:Realms.Realm.GetInstance(System.String)">
             <summary>
             Factory for a Realm instance for this thread.
             </summary>
             <param name="databasePath">Path to the realm, must be a valid full path for the current platform, relative subdirectory, or just filename.</param>
             <remarks>If you specify a relative path, sandboxing by the OS may cause failure if you specify anything other than a subdirectory. <br />
             Instances are cached for a given absolute path and thread, so you may get back the same instance.
             </remarks>
             <returns>A realm instance, possibly from cache.</returns>
             <exception cref="T:Realms.RealmFileAccessErrorException">Throws error if the file system returns an error preventing file creation.</exception>
            </member>
        <member name="M:Realms.Realm.GetInstance(Realms.RealmConfigurationBase)">
             <summary>
             Factory for a Realm instance for this thread.
             </summary>
             <param name="config">Optional configuration.</param>
             <returns>A realm instance.</returns>
             <exception cref="T:Realms.RealmFileAccessErrorException">Throws error if the file system returns an error, preventing file creation.</exception>
            </member>
        <member name="M:Realms.Realm.Compact(Realms.RealmConfigurationBase)">
             <summary>
             Compacts a Realm file. A Realm file usually contains free/unused space. This method removes this free space and the file size is thereby reduced. Objects within the Realm file are untouched.
             </summary>
             <remarks>
             The realm file must not be open on other threads.
             The file system should have free space for at least a copy of the Realm file.
             This method must not be called inside a transaction.
             The Realm file is left untouched if any file operation fails.
             </remarks>
             <param name="config">Optional configuration.</param>
             <returns><c>true</c> if successful, <c>false</c> if any file operation failed.</returns>
            </member>
        <member name="P:Realms.Realm.Schema">
             <summary>
             Gets the <see cref="T:Realms.RealmSchema" /> instance that describes all the types that can be stored in this <see cref="T:Realms.Realm" />.
             </summary>
            </member>
        <member name="P:Realms.Realm.Config">
             <summary>
             Gets the <see cref="T:Realms.RealmConfigurationBase" /> that controls this realm's path and other settings.
             </summary>
            </member>
        <member name="T:Realms.Realm.RealmChangedEventHandler">
             <summary>
             Handler type used by <see cref="E:Realms.Realm.RealmChanged" /> 
             </summary>
             <param name="sender">The Realm which has changed.</param>
             <param name="e">Currently an empty argument, in future may indicate more details about the change.</param>
            </member>
        <member name="E:Realms.Realm.RealmChanged">
             <summary>
             Triggered when a realm has changed (i.e. a transaction was committed).
             </summary>
            </member>
        <member name="E:Realms.Realm.Error">
             <summary>
             Triggered when a Realm-level exception has occurred.
             </summary>
            </member>
        <member name="P:Realms.Realm.IsClosed">
             <summary>
             Checks if database has been closed.
             </summary>
             <returns>True if closed.</returns>
            </member>
        <member name="M:Realms.Realm.Dispose">
             <summary>
              Dispose automatically closes the Realm if not already closed.
             </summary>
            </member>
        <member name="M:Realms.Realm.Equals(System.Object)">
             <summary>
             Generic override determines whether the specified <see cref="T:System.Object" /> is equal to the current Realm.
             </summary>
             <param name="obj">The <see cref="T:System.Object" /> to compare with the current Realm.</param>
             <returns><c>true</c> if the Realms are functionally equal.</returns>
            </member>
        <member name="M:Realms.Realm.Equals(Realms.Realm)">
             <summary>
             Determines whether the specified Realm is equal to the current Realm.
             </summary>
             <param name="other">The Realm to compare with the current Realm.</param>
             <returns><c>true</c> if the Realms are functionally equal.</returns>
            </member>
        <member name="M:Realms.Realm.IsSameInstance(Realms.Realm)">
             <summary>
             Determines whether this instance is the same core instance as the passed in argument.
             </summary>
             <remarks>
             You can, and should, have multiple instances open on different threads which have the same path and open the same Realm.
             </remarks>
             <returns><c>true</c> if this instance is the same core instance; otherwise, <c>false</c>.</returns>
             <param name="other">The Realm to compare with the current Realm.</param>
            </member>
        <member name="M:Realms.Realm.GetHashCode">
             <summary>
             Serves as a hash function for a Realm based on the core instance.
             </summary>
             <returns>A hash code for this instance that is suitable for use in hashing algorithms and data structures such as a
             hash table.</returns>
            </member>
        <member name="M:Realms.Realm.DeleteRealm(Realms.RealmConfigurationBase)">
             <summary>
              Deletes all the files associated with a realm. Hides knowledge of the auxiliary filenames from the programmer.
             </summary>
             <param name="configuration">A configuration which supplies the realm path.</param>
            </member>
        <member name="M:Realms.Realm.CreateObject``1">
             <summary>
             <b>Deprecated</b> Factory for a managed object in a realm. Only valid within a Write transaction.
             </summary>
             <remarks>Scheduled for removal in the next major release, as it is dangerous to call CreateObject and then assign a PrimaryKey.</remarks>
             <typeparam name="T">The Type T must be a RealmObject.</typeparam>
             <returns>An object which is already managed.</returns>
             <exception cref="T:Realms.RealmInvalidTransactionException">If you invoke this when there is no write Transaction active on the realm.</exception>
            </member>
        <member name="M:Realms.Realm.CreateObject(System.String)">
             <summary>
             Factory for a managed object in a realm. Only valid within a Write transaction.
             </summary>
             <returns>A dynamically-accessed Realm object.</returns>
             <param name="className">The type of object to create as defined in the schema.</param>
             <remarks>
             <b>WARNING:</b> if the dynamic object has a PrimaryKey then that must be the <b>first property set</b> otherwise other property changes may be lost.<br />
             If the realm instance has been created from an un-typed schema (such as when migrating from an older version of a realm) the returned object will be purely dynamic.
             If the realm has been created from a typed schema as is the default case when calling <code>Realm.GetInstance()</code> the returned object will be an instance of a user-defined class, as if created by <code>Realm.CreateObject&lt;T&gt;()</code>.
             </remarks>
            </member>
        <member name="M:Realms.Realm.Add``1(``0,System.Boolean)">
             <summary>
             This realm will start managing a RealmObject which has been created as a standalone object.
             </summary>
             <typeparam name="T">The Type T must not only be a RealmObject but also have been processed by the Fody weaver, so it has persistent properties.</typeparam>
             <param name="obj">Must be a standalone object, null not allowed.</param>
             <param name="update">If true, and an object with the same primary key already exists, performs an update.</param>
             <exception cref="T:Realms.RealmInvalidTransactionException">If you invoke this when there is no write Transaction active on the realm.</exception>
             <exception cref="T:Realms.RealmObjectManagedByAnotherRealmException">You can't manage an object with more than one realm</exception>
             <remarks>
             If the object is already managed by this realm, this method does nothing.
             This method modifies the object in-place, meaning that after it has run, <c>obj</c> will be managed. Returning it is just meant as a convenience to enable fluent syntax scenarios.
             Cyclic graphs (<c>Parent</c> has <c>Child</c> that has a <c>Parent</c>) will result in undefined behavior. You have to break the cycle manually and assign relationships after all object have been managed.
             </remarks>
             <returns>The passed object, so that you can write <c>var person = realm.Add(new Person { Id = 1 });</c></returns>
            </member>
        <member name="M:Realms.Realm.Add(Realms.RealmObject,System.Boolean)">
             <summary>
             This realm will start managing a RealmObject which has been created as a standalone object.
             </summary>
             <param name="obj">Must be a standalone object, null not allowed.</param>
             <param name="update">If true, and an object with the same primary key already exists, performs an update.</param>
             <exception cref="T:Realms.RealmInvalidTransactionException">If you invoke this when there is no write Transaction active on the realm.</exception>
             <exception cref="T:Realms.RealmObjectManagedByAnotherRealmException">You can't manage an object with more than one realm</exception>
             <remarks>
             If the object is already managed by this realm, this method does nothing.
             This method modifies the object in-place, meaning that after it has run, <c>obj</c> will be managed.
             Cyclic graphs (<c>Parent</c> has <c>Child</c> that has a <c>Parent</c>) will result in undefined behavior. You have to break the cycle manually and assign relationships after all object have been managed.
             </remarks>
            </member>
        <member name="M:Realms.Realm.BeginWrite">
             <summary>
             Factory for a write Transaction. Essential object to create scope for updates.
             </summary>
             <example><c>
             using (var trans = realm.BeginWrite()) 
             { 
                 var rex = realm.CreateObject&lt;Dog&gt;();
                 rex.Name = "Rex";
                 trans.Commit();
             }</c>
             </example>
             <returns>A transaction in write mode, which is required for any creation or modification of objects persisted in a Realm.</returns>
            </member>
        <member name="M:Realms.Realm.Write(System.Action)">
             <summary>
             Execute an action inside a temporary transaction. If no exception is thrown, the transaction will automatically
             be committed.
             </summary>
             <remarks>
             Creates its own temporary transaction and commits it after running the lambda passed to `action`. 
             Be careful of wrapping multiple single property updates in multiple `Write` calls. It is more efficient to update several properties 
             or even create multiple objects in a single Write, unless you need to guarantee finer-grained updates.
             </remarks>
             <example><c>
             realm.Write(() =&gt; 
             {
                 d = realm.CreateObject&lt;Dog&gt;();
                 d.Name = "Eddie";
                 d.Age = 5;
             });</c>
             </example>
             <param name="action">Action to perform inside a transaction, creating, updating or removing objects.</param>
            </member>
        <member name="M:Realms.Realm.WriteAsync(System.Action{Realms.Realm})">
             <summary>
             Execute an action inside a temporary transaction on a worker thread. If no exception is thrown, the transaction will automatically
             be committed.
             </summary>
             <remarks>
             Opens a new instance of this realm on a worker thread and executes <c>action</c> inside a write transaction.
             Realms and realm objects are thread-affine, so capturing any such objects in the <c>action</c> delegate will lead to errors
             if they're used on the worker thread.
             </remarks>
             <example>
             <c>
             await realm.WriteAsync(tempRealm =&gt; 
             {
                 var pongo = tempRealm.All&lt;Dog&gt;().Single(d =&gt; d.Name == "Pongo");
                 var missis = tempRealm.All&lt;Dog&gt;().Single(d =&gt; d.Name == "Missis");
                 for (var i = 0; i &lt; 15; i++)
                 {
                     tempRealm.Add(new Dog
                     {
                         Breed = "Dalmatian",
                         Mum = missis,
                         Dad = pongo
                     });
                 }
             });
             </c>
             Note that inside the action, we use <c>tempRealm</c>.
             </example>
             <param name="action">Action to perform inside a transaction, creating, updating or removing objects.</param>
             <returns>A standard <c>Task</c> so it can be used by <c>await</c>.</returns>
            </member>
        <member name="M:Realms.Realm.Refresh">
             <summary>
             Update a Realm and outstanding objects to point to the most recent data for this Realm.
             This is only necessary when you have a Realm on a thread without a runloop that needs manual refreshing.
             </summary>
             <returns>
             Whether the realm had any updates. Note that this may return true even if no data has actually changed.
             </returns>
            </member>
        <member name="M:Realms.Realm.All``1">
             <summary>
             Extract an iterable set of objects for direct use or further query.
             </summary>
             <typeparam name="T">The Type T must be a RealmObject.</typeparam>
             <returns>A queryable collection that without further filtering, allows iterating all objects of class T, in this realm.</returns>
            </member>
        <member name="M:Realms.Realm.All(System.String)">
             <summary>
             Get a view of all the objects of a particular type.
             </summary>
             <param name="className">The type of the objects as defined in the schema.</param>
             <remarks>Because the objects inside the view are accessed dynamically, the view cannot be queried into using LINQ or other expression predicates.</remarks>
             <returns>A queryable collection that without further filtering, allows iterating all objects of className, in this realm.</returns>
            </member>
        <member name="M:Realms.Realm.Find``1(System.Nullable{System.Int64})">
             <summary>
             Fast lookup of an object from a class which has a PrimaryKey property.
             </summary>
             <typeparam name="T">The Type T must be a RealmObject.</typeparam>
             <param name="primaryKey">Primary key to be matched exactly, same as an == search. An argument of type <c>long?</c> works for all integer properties, supported as PrimaryKey.</param>
             <returns>Null or an object matching the primary key.</returns>
             <exception cref="T:Realms.RealmClassLacksPrimaryKeyException">If the RealmObject class T lacks an [PrimaryKey].</exception>
            </member>
        <member name="M:Realms.Realm.Find``1(System.String)">
             <summary>
             Fast lookup of an object from a class which has a PrimaryKey property.
             </summary>
             <typeparam name="T">The Type T must be a RealmObject.</typeparam>
             <param name="primaryKey">Primary key to be matched exactly, same as an == search.</param>
             <returns>Null or an object matching the primary key.</returns>
             <exception cref="T:Realms.RealmClassLacksPrimaryKeyException">If the RealmObject class T lacks an [PrimaryKey].</exception>
            </member>
        <member name="M:Realms.Realm.Find(System.String,System.Nullable{System.Int64})">
             <summary>
             Fast lookup of an object for dynamic use, from a class which has a PrimaryKey property.
             </summary>
             <param name="className">Name of class in dynamic situation.</param>
             <param name="primaryKey">Primary key to be matched exactly, same as an == search. An argument of type <c>long?</c> works for all integer properties, supported as PrimaryKey.</param>
             <returns>Null or an object matching the primary key.</returns>
             <exception cref="T:Realms.RealmClassLacksPrimaryKeyException">If the RealmObject class lacks an [PrimaryKey].</exception>
            </member>
        <member name="M:Realms.Realm.Find(System.String,System.String)">
             <summary>
             Fast lookup of an object for dynamic use, from a class which has a PrimaryKey property.
             </summary>
             <param name="className">Name of class in dynamic situation.</param>
             <param name="primaryKey">Primary key to be matched exactly, same as an == search.</param>
             <returns>Null or an object matching the primary key.</returns>
             <exception cref="T:Realms.RealmClassLacksPrimaryKeyException">If the RealmObject class lacks an [PrimaryKey].</exception>
            </member>
        <member name="M:Realms.Realm.Remove(Realms.RealmObject)">
             <summary>
             Removes a persistent object from this realm, effectively deleting it.
             </summary>
             <param name="obj">Must be an object persisted in this realm.</param>
             <exception cref="T:Realms.RealmInvalidTransactionException">If you invoke this when there is no write Transaction active on the realm.</exception>
             <exception cref="T:System.ArgumentNullException">If you invoke this with a standalone object.</exception>
            </member>
        <member name="M:Realms.Realm.RemoveRange``1(System.Linq.IQueryable{``0})">
             <summary>
             Remove objects matching a query from the realm.
             </summary>
             <typeparam name="T">Type of the objects to remove.</typeparam>
             <param name="range">The query to match for.</param>
            </member>
        <member name="M:Realms.Realm.RemoveAll``1">
             <summary>
             Remove all objects of a type from the realm.
             </summary>
             <typeparam name="T">Type of the objects to remove.</typeparam>
            </member>
        <member name="M:Realms.Realm.RemoveAll(System.String)">
             <summary>
             Remove all objects of a type from the realm.
             </summary>
             <param name="className">Type of the objects to remove as defined in the schema.</param>
            </member>
        <member name="M:Realms.Realm.RemoveAll">
             <summary>
             Remove all objects of all types managed by this realm.
             </summary>
            </member>
        <member name="M:Realms.Realm.ObjectForPrimaryKey``1(System.Int64)">
             <summary>
             Fast lookup of an object from a class which has a PrimaryKey property.
             </summary>
             <typeparam name="T">The Type T must be a RealmObject.</typeparam>
             <param name="id">Id to be matched exactly, same as an == search. <see cref="T:System.Int64" /> argument works for all integer properties supported as PrimaryKey.</param>
             <returns>Null or an object matching the id.</returns>
             <exception cref="T:Realms.RealmClassLacksPrimaryKeyException">If the RealmObject class T lacks an [PrimaryKey].</exception>
            </member>
        <member name="M:Realms.Realm.ObjectForPrimaryKey``1(System.String)">
             <summary>
             Fast lookup of an object from a class which has a PrimaryKey property.
             </summary>
             <typeparam name="T">The Type T must be a RealmObject.</typeparam>
             <param name="id">Id to be matched exactly, same as an == search.</param>
             <returns>Null or an object matching the id.</returns>
             <exception cref="T:Realms.RealmClassLacksPrimaryKeyException">If the RealmObject class T lacks an [PrimaryKey].</exception>
            </member>
        <member name="M:Realms.Realm.ObjectForPrimaryKey(System.String,System.Int64)">
             <summary>
             Fast lookup of an object for dynamic use, from a class which has a PrimaryKey property.
             </summary>
             <param name="className">Name of class in dynamic situation.</param>
             <param name="id">Id to be matched exactly, same as an == search.</param>
             <returns>Null or an object matching the id.</returns>
             <exception cref="T:Realms.RealmClassLacksPrimaryKeyException">If the RealmObject class lacks an [PrimaryKey].</exception>
            </member>
        <member name="M:Realms.Realm.ObjectForPrimaryKey(System.String,System.String)">
             <summary>
             Fast lookup of an object for dynamic use, from a class which has a PrimaryKey property.
             </summary>
             <param name="className">Name of class in dynamic situation.</param>
             <param name="id">Id to be matched exactly, same as an == search.</param>
             <returns>Null or an object matching the id.</returns>
             <exception cref="T:Realms.RealmClassLacksPrimaryKeyException">If the RealmObject class lacks an [PrimaryKey].</exception>
            </member>
        <member name="M:Realms.Realm.Manage``1(``0,System.Boolean)">
             <summary>
             This realm will start managing a RealmObject which has been created as a standalone object.
             </summary>
             <typeparam name="T">The Type T must not only be a RealmObject but also have been processed by the Fody weaver, so it has persistent properties.</typeparam>
             <param name="obj">Must be a standalone object, null not allowed.</param>
             <param name="update">If true, and an object with the same primary key already exists, performs an update.</param>
             <exception cref="T:Realms.RealmInvalidTransactionException">If you invoke this when there is no write Transaction active on the realm.</exception>
             <exception cref="T:Realms.RealmObjectManagedByAnotherRealmException">You can't manage an object with more than one realm</exception>
            </member>
        <member name="M:Realms.Realm.Close">
             <summary>
             Closes the Realm if not already closed. Safe to call repeatedly.
             Note that this will close the file. Other references to the same database
             on the same thread will be invalidated.
             </summary>
            </member>
        <member name="T:Realms.RealmList`1">
             <summary>
             Return type for a managed object property when you declare a to-many relationship with IList. 
             </summary>
             <remarks>Relationships are ordered and preserve their order, hence the ability to use ordinal 
             indexes in calls such as Insert and RemoveAt.
             </remarks>
             <remarks>Although originally used in declarations, whilst that still compiles, 
             it is <b>not</b> recommended as the IList approach both supports standalone objects and is 
             implemented with a faster binding.
             </remarks>
             <typeparam name="T">Type of the RealmObject which is the target of the relationship.</typeparam>
            </member>
        <member name="T:Realms.RealmObject">
             <summary>
             Base for any object that can be persisted in a Realm.
             </summary>
             <remarks>
             Has a Preserve attribute to attempt to preserve all subtypes without having to weave.
             </remarks>
            </member>
        <member name="E:Realms.RealmObject.PropertyChanged">
             <summary>
             Occurs when a property value changes.
             </summary>
            </member>
        <member name="P:Realms.RealmObject.IsManaged">
             <summary>
             Gets a value indicating whether the object has been associated with a Realm, either at creation or via Realm.Add.
             </summary>
            </member>
        <member name="P:Realms.RealmObject.IsValid">
             <summary>
             Gets a value indicating whether this object is managed and represents a row in the database.
             If a managed object has been removed from the Realm, it is no longer valid and accessing properties on it
             will throw an exception.
             Unmanaged objects are always considered valid.
             </summary>
            </member>
        <member name="P:Realms.RealmObject.Realm">
             <summary>
             Gets the <see cref="T:Realms.Realm" /> instance this object belongs to, or <code>null</code> if it is unmanaged.
             </summary>
            </member>
        <member name="P:Realms.RealmObject.ObjectSchema">
             <summary>
             Gets the <see cref="T:Realms.Schema.ObjectSchema" /> instance that describes how the <see cref="T:Realms.Realm" /> this object belongs to sees it.
             </summary>
            </member>
        <member name="M:Realms.RealmObject.Equals(System.Object)">
             <summary>
             Compare objects with identity query for persistent objects.
             </summary>
             <remarks>Persisted RealmObjects map their properties directly to the realm with no caching so multiple instances of a given object always refer to the same store.</remarks>
             <param name="obj">Object being compared against to see if is the same C# object or maps to the same managed object in Realm.</param>
             <returns>True when objects are the same memory object or refer to the same persisted object.</returns>
            </member>
        <member name="M:Realms.RealmObject.RaisePropertyChanged(System.String)">
             <summary>
             Allows you to raise the PropertyChanged event.
             </summary>
             <param name="propertyName">The name of the property that has changed. If not specified, we'll use the caller name.</param>
            </member>
        <member name="M:Realms.RealmObject.OnPropertyChanged(System.String)">
             <summary>
             Called when a property has changed on this class.
             </summary>
             <param name="propertyName">Property name.</param>
             <remarks>
             For this method to be called, you need to have first subscribed to <see cref="E:Realms.RealmObject.PropertyChanged" />.
             This can be used to react to changes to the current object, e.g. raising `PropertyChanged` for computed properties.
             </remarks>
             <example>
             <c>
             class MyClass : RealmObject
             {
                 public int StatusCodeRaw { get; set; }
             
                 public StatusCodeEnum StatusCode =&gt; (StatusCodeEnum)StatusCodeRaw;
             
                 protected override void OnPropertyChanged(string propertyName)
                 {
                     if (propertyName == nameof(StatusCodeRaw))
                     {
                         RaisePropertyChanged(nameof(StatusCode));
                     }
                 }
             }
             </c>
             Here, we have a computed property that depends on a persisted one. In order to notify any <see cref="E:Realms.RealmObject.PropertyChanged" />
             subscribers that <c>StatusCode</c> has changed, we override <c>OnPropertyChanged</c> and raise <c>PropertyChanged</c>
             manually.
             </example>
            </member>
        <member name="T:Realms.RealmException">
             <summary>
             Base for Realm specific exceptions. Use only for catching.
             </summary>
            </member>
        <member name="T:Realms.RealmExceptionCodes">
             <summary>Codes used in forwarding exceptions from the native C++ core, to be regenerated in C#.</summary>
             <remarks> <b>Warning:</b> Keep these codes aligned with realm_error_type.hpp in wrappers.</remarks>
            </member>
        <member name="T:Realms.RealmFileAccessErrorException">
             <summary>
             Base for catching exceptions with Realm files, typically problems from which an app would recover.
             </summary>
             <remarks>
             You can catch any of the subclasses independently but any File-level error which could be handled by an application descends from these.
             </remarks>
            </member>
        <member name="T:Realms.RealmFileNotFoundException">
             <summary>
             Exception thrown when a file doesn't exist when trying to open without a create option.
             </summary>
            </member>
        <member name="T:Realms.RealmOutOfMemoryException">
             <summary>
             Exception when Realm's run out of memory, shut down your application rather than trying to continue.
             </summary>
            </member>
        <member name="T:Realms.Transaction">
             <summary>
             Provides a scope to safely read and write to a Realm. Must use explicitly via Realm.BeginWrite.
             </summary>
             <remarks>
             All access to a Realm occurs within a Transaction. Read transactions are created implicitly.
             </remarks>
            </member>
        <member name="M:Realms.Transaction.Dispose">
             <summary>
             Will automatically <c>Rollback</c> the transaction on existing scope, if not explicitly Committed.
             </summary>
            </member>
        <member name="M:Realms.Transaction.Rollback">
             <summary>
             Use explicitly to undo the changes in a transaction, otherwise it is automatically invoked by exiting the block.
             </summary>
            </member>
        <member name="M:Realms.Transaction.Commit">
             <summary>
             Use to save the changes to the realm. If transaction is declared in a <c>using</c> block, must be used before the end of that block.
             </summary>
            </member>
        <member name="T:Realms.RealmConfigurationBase">
             <summary>
             Base class for specifying configuration specifying settings that affect the Realm's behavior.
             </summary>
            </member>
        <member name="P:Realms.RealmConfigurationBase.DefaultRealmName">
             <summary>
             Gets the filename to be combined with the platform-specific document directory.
             </summary>
             <value>A string representing a filename only, no path.</value>
            </member>
        <member name="P:Realms.RealmConfigurationBase.DatabasePath">
             <summary>
             Gets or sets the full path of the realms opened with this configuration, may be overriden by passing in a separate name.
             </summary>
            </member>
        <member name="P:Realms.RealmConfigurationBase.ObjectClasses">
             <summary>
             Gets or sets the list of classes persisted in a Realm opened with this configuration.
             </summary>
             <remarks>Specify classes by type. Searched linearly so order in decreasing frequency of creating objects.</remarks>
             <example>For example: `config.ObjectClasses = new Type[] { typeof(CommonClass), typeof(RareClass) };`.</example>
             <value>Typically left null so by default all RealmObjects will be able to be stored in all realms.</value>
            </member>
        <member name="M:Realms.RealmConfigurationBase.GetPathToRealm(System.String)">
             <summary>
             Utility to build a path in which a realm will be created so can consistently use filenames and relative paths.
             </summary>
             <param name="optionalPath">Path to the realm, must be a valid full path for the current platform, relative subdirectory, or just filename.</param>
             <returns>A full path including name of Realm file.</returns>
            </member>
        <member name="P:Realms.RealmConfigurationBase.SchemaVersion">
             <summary>
             Gets or sets a number, indicating the version of the schema. Can be used to arbitrarily distinguish between schemas even if they have the same objects and properties.
             </summary>
             <value>0-based value initially set to zero so all user-set values will be greater.</value>
            </member>
        <member name="P:Realms.RealmConfigurationBase.EncryptionKey">
             <summary>
             Gets or sets the key, used to encrypt the entire Realm. Once set, must be specified each time file is used.
             </summary>
             <value>Full 64byte (512bit) key for AES-256 encryption.</value>
            </member>
        <member name="T:Realms.RealmMigrationNeededException">
             <summary>
             Exception when you can't open an existing realm file because the format differs from your current class declarations.
             </summary>
             <remarks>
             Typically triggered when you open the same Realm name, or use GetInstance() with no name, 
             and don't delete old files. <a href="https://realm.io/docs/xamarin/latest/#migrations">Read more at Migrations.</a>
             </remarks>
            </member>
        <member name="T:Realms.RealmMismatchedConfigException">
             <summary>
             An exception, thrown when you try to open a Realm file with a different RealmConfiguration.
             </summary>
            </member>
        <member name="T:Realms.Weaving.IRealmObjectHelper">
             <summary>
             A helper class for internal use. Helper classes are generated automatically and provide strongly typed class-specific convenience methods.
             </summary>
            </member>
        <member name="M:Realms.Weaving.IRealmObjectHelper.CreateInstance">
             <summary>
             Creates an instance of a RealmObject.
             </summary>
             <returns>The RealmObject.</returns>
            </member>
        <member name="M:Realms.Weaving.IRealmObjectHelper.CopyToRealm(Realms.RealmObject,System.Boolean,System.Boolean)">
             <summary>
             A strongly typed, optimized method to add a RealmObject to the realm.
             </summary>
             <param name="instance">The RealmObject to add.</param>
             <param name="update">If set to <c>true</c>, update the existing value (if any). Otherwise, try to add and throw if an object with the same primary key already exists.</param>
             <param name="setPrimaryKey">If set to <c>true</c> will set the primary key of the object (if any).</param>
            </member>
        <member name="M:Realms.Weaving.IRealmObjectHelper.TryGetPrimaryKeyValue(Realms.RealmObject,System.Object@)">
             <summary>
             Tries the get primary key value from a RealmObject.
             </summary>
             <returns><c>true</c>, if the class has primary key, <c>false</c> otherwise.</returns>
             <param name="instance">The RealmObject instance.</param>
             <param name="value">The value of the primary key.</param>
            </member>
        <member name="T:Realms.RealmInvalidTransactionException">
             <summary>
             An exception, thrown when trying to write data to the Realm and you haven't begun a Write transaction or when the realm is opened as read-only.
             </summary>
            </member>
        <member name="T:Realms.CollectionNotificationsExtensions">
             <summary>
             A set of extensions methods exposing notification-related functionality over collections.
             </summary>
            </member>
        <member name="M:Realms.CollectionNotificationsExtensions.AsRealmCollection``1(System.Linq.IQueryable{``0})">
             <summary>
             A convenience method that casts <c>IQueryable{T}</c> to <see cref="T:Realms.IRealmCollection`1" /> which implements INotifyCollectionChanged.
             </summary>
             <param name="results">The <see cref="T:System.Linq.IQueryable`1" /> to observe for changes.</param>
             <typeparam name="T">Type of the RealmObject in the results.</typeparam>
             <seealso cref="M:Realms.IRealmCollection`1.SubscribeForNotifications(Realms.NotificationCallbackDelegate{`0})" />
             <returns>The collection, implementing <see cref="T:System.Collections.Specialized.INotifyCollectionChanged" />.</returns>
            </member>
        <member name="M:Realms.CollectionNotificationsExtensions.SubscribeForNotifications``1(System.Linq.IQueryable{``0},Realms.NotificationCallbackDelegate{``0})">
             <summary>
             A convenience method that casts <c>IQueryable{T}</c> to <see cref="T:Realms.IRealmCollection`1" /> and subscribes for change notifications.
             </summary>
             <param name="results">The <see cref="T:System.Linq.IQueryable`1" /> to observe for changes.</param>
             <typeparam name="T">Type of the RealmObject in the results.</typeparam>
             <seealso cref="M:Realms.IRealmCollection`1.SubscribeForNotifications(Realms.NotificationCallbackDelegate{`0})" />
             <param name="callback">The callback to be invoked with the updated <see cref="T:Realms.IRealmCollection`1" />.</param>
             <returns>
             A subscription token. It must be kept alive for as long as you want to receive change notifications.
             To stop receiving notifications, call <see cref="M:System.IDisposable.Dispose" />.
             </returns>
            </member>
        <member name="M:Realms.CollectionNotificationsExtensions.AsRealmCollection``1(System.Collections.Generic.IList{``0})">
             <summary>
             A convenience method that casts <c>IList{T}</c> to <see cref="T:Realms.IRealmCollection`1" /> which implements INotifyCollectionChanged.
             </summary>
             <param name="list">The <see cref="T:System.Collections.Generic.IList`1" /> to observe for changes.</param>
             <typeparam name="T">Type of the RealmObject in the list.</typeparam>
             <seealso cref="M:Realms.IRealmCollection`1.SubscribeForNotifications(Realms.NotificationCallbackDelegate{`0})" />
             <returns>The collection, implementing <see cref="T:System.Collections.Specialized.INotifyCollectionChanged" />.</returns>
            </member>
        <member name="M:Realms.CollectionNotificationsExtensions.SubscribeForNotifications``1(System.Collections.Generic.IList{``0},Realms.NotificationCallbackDelegate{``0})">
             <summary>
             A convenience method that casts <c>IList{T}</c> to <see cref="T:Realms.IRealmCollection`1" /> and subscribes for change notifications.
             </summary>
             <param name="results">The <see cref="T:System.Collections.Generic.IList`1" /> to observe for changes.</param>
             <typeparam name="T">Type of the RealmObject in the results.</typeparam>
             <seealso cref="M:Realms.IRealmCollection`1.SubscribeForNotifications(Realms.NotificationCallbackDelegate{`0})" />
             <param name="callback">The callback to be invoked with the updated <see cref="T:Realms.IRealmCollection`1" />.</param>
             <returns>
             A subscription token. It must be kept alive for as long as you want to receive change notifications.
             To stop receiving notifications, call <see cref="M:System.IDisposable.Dispose" />.
             </returns>
            </member>
        <member name="M:Realms.CollectionNotificationsExtensions.Move``1(System.Collections.Generic.IList{``0},``0,System.Int32)">
             <summary>
             Move the specified item to a new position within the list.
             </summary>
             <param name="list">The list where the move should occur.</param>
             <param name="item">The item that will be moved.</param>
             <param name="index">The new position to which the item will be moved.</param>
             <typeparam name="T">Type of the RealmObject in the list.</typeparam>
             <remarks>
             This extension method will work for standalone lists as well by calling <c>Remove</c> and then <c>Insert</c>.
             </remarks>
             <exception cref="T:System.ArgumentOutOfRangeException">Thrown if the index is less than 0 or greater than Count - 1.</exception>
            </member>
        <member name="M:Realms.CollectionNotificationsExtensions.ToNotifyCollectionChanged``1(System.Linq.IOrderedQueryable{``0},System.Action{System.Exception})">
             <summary>
             A convenience method that casts <c>IQueryable{T}</c> to <see cref="T:Realms.IRealmCollection`1" /> which implements INotifyCollectionChanged.
             </summary>
             <param name="results">The <see cref="T:System.Linq.IQueryable`1" /> to observe for changes.</param>
             <param name="errorCallback">The parameter is not used.</param>
             <typeparam name="T">Type of the RealmObject in the results.</typeparam>
             <returns>The collection, implementing <see cref="T:System.Collections.Specialized.INotifyCollectionChanged" />.</returns>
             <seealso cref="M:Realms.IRealmCollection`1.SubscribeForNotifications(Realms.NotificationCallbackDelegate{`0})" />
            </member>
        <member name="M:Realms.CollectionNotificationsExtensions.ToNotifyCollectionChanged``1(System.Linq.IOrderedQueryable{``0},System.Action{System.Exception},System.Boolean)">
             <summary>
             A convenience method that casts <c>IQueryable{T}</c> to <see cref="T:Realms.IRealmCollection`1" /> which implements INotifyCollectionChanged.
             </summary>
             <param name="results">The <see cref="T:System.Linq.IQueryable`1" /> to observe for changes.</param>
             <param name="errorCallback">The parameter is not used.</param>
             <param name="coalesceMultipleChangesIntoReset">The parameter is not used.</param>
             <typeparam name="T">Type of the RealmObject in the results.</typeparam>
             <returns>The collection, implementing <see cref="T:System.Collections.Specialized.INotifyCollectionChanged" />.</returns>
             <seealso cref="M:Realms.IRealmCollection`1.SubscribeForNotifications(Realms.NotificationCallbackDelegate{`0})" />
            </member>
        <member name="T:Realms.RealmSchema">
             <summary>
             Describes the complete set of classes which may be stored in a Realm, either from assembly declarations or, dynamically, by evaluating a Realm from disk.
             </summary>
             <remarks>
             By default this will be all the RealmObjects in all your assemblies unless you restrict with RealmConfiguration.ObjectClasses. 
             Just because a given class <em>may</em> be stored in a Realm doesn't imply much overhead. There will be a small amount of metadata
             but objects only start to take up space once written. 
             </remarks>
            </member>
        <member name="P:Realms.RealmSchema.Count">
             <summary>
             Gets the number of known classes in the schema.
             </summary>
            </member>
        <member name="M:Realms.RealmSchema.Find(System.String)">
             <summary>
             Finds the definition of a class in this schema.
             </summary>
             <param name="name">A valid class name which may be in this schema.</param>
             <exception cref="T:System.ArgumentException">Thrown if a name is not supplied.</exception>
             <returns>An object or null to indicate not found.</returns>
            </member>
        <member name="M:Realms.RealmSchema.GetEnumerator">
             <summary>
             Standard method from interface IEnumerable allows the RealmSchema to be used in a <c>foreach</c> or <c>ToList()</c>.
             </summary>
             <returns>An IEnumerator which will iterate through ObjectSchema declarations in this RealmSchema.</returns>
            </member>
        <member name="T:Realms.RealmSchema.Builder">
             <summary>
             Helper class used to construct a RealmSchema.
             </summary>
            </member>
        <member name="M:Realms.RealmSchema.Builder.Build">
             <summary>
             Build the RealmSchema to include all ObjectSchema added to this Builder.
             </summary>
             <exception cref="T:System.InvalidOperationException">Thrown if the Builder is empty.</exception>
             <returns>A completed RealmSchema, suitable for creating a new Realm.</returns>
            </member>
        <member name="T:Realms.Schema.PropertyType">
             <summary>
             An enum, containing the possible property types.
             </summary>
            </member>
        <member name="F:Realms.Schema.PropertyType.Int">
             <summary>
             Integer property, combining all integral types.
             </summary>
            </member>
        <member name="F:Realms.Schema.PropertyType.Bool">
             <summary>
             Boolean property.
             </summary>
            </member>
        <member name="F:Realms.Schema.PropertyType.Float">
             <summary>
             32 bit floating point property.
             </summary>
            </member>
        <member name="F:Realms.Schema.PropertyType.Double">
             <summary>
             64 bit floating point property.
             </summary>
            </member>
        <member name="F:Realms.Schema.PropertyType.String">
             <summary>
             String property.
             </summary>
            </member>
        <member name="F:Realms.Schema.PropertyType.Data">
             <summary>
             Binary data (byte[]) property.
             </summary>
            </member>
        <member name="F:Realms.Schema.PropertyType.Any">
             <summary>
             Any property type.
             </summary>
            </member>
        <member name="F:Realms.Schema.PropertyType.Date">
             <summary>
             DateTimeOffset property.
             </summary>
            </member>
        <member name="F:Realms.Schema.PropertyType.Object">
             <summary>
             Related object property, representing a one-to-one or many-to-one relationship.
             </summary>
            </member>
        <member name="F:Realms.Schema.PropertyType.Array">
             <summary>
             A collection of related objects property, representing one-to-many relationship.
             </summary>
            </member>
        <member name="F:Realms.Schema.PropertyType.LinkingObjects">
             <summary>
             A collection of objects linking to the model owning this property.
             </summary>
            </member>
        <member name="T:Realms.Schema.Property">
             <summary>
             Describes a single property of a class stored in a Realm.
             </summary>
            </member>
        <member name="P:Realms.Schema.Property.Name">
             <summary>
             Gets or sets the name of the property.
             </summary>
            </member>
        <member name="P:Realms.Schema.Property.Type">
             <summary>
             Gets or sets the type of the property.
             </summary>
            </member>
        <member name="P:Realms.Schema.Property.ObjectType">
             <summary>
             Gets or sets the type of the object.
             </summary>
            </member>
        <member name="P:Realms.Schema.Property.LinkOriginPropertyName">
             <summary>
             Gets or sets the name of the property that links to the model containing this <see cref="F:Realms.Schema.PropertyType.LinkingObjects" /> property.
             </summary>
            </member>
        <member name="P:Realms.Schema.Property.IsNullable">
             <summary>
             Gets or sets a value indicating whether this <see cref="T:Realms.Schema.Property" /> can be null.
             </summary>
            </member>
        <member name="P:Realms.Schema.Property.IsPrimaryKey">
             <summary>
             Gets or sets a value indicating whether this <see cref="T:Realms.Schema.Property" /> is primary key.
             </summary>
            </member>
        <member name="P:Realms.Schema.Property.IsIndexed">
             <summary>
             Gets or sets a value indicating whether this <see cref="T:Realms.Schema.Property" /> is indexed.
             </summary>
            </member>
        <member name="T:Realms.Schema.ObjectSchema">
             <summary>
             Public description of a class stored in a Realm, as a collection of managed Property objects.
             </summary>
            </member>
        <member name="P:Realms.Schema.ObjectSchema.Name">
             <summary>
             Gets the name of the original class declaration from which the schema was built.
             </summary>
            </member>
        <member name="P:Realms.Schema.ObjectSchema.Count">
             <summary>
             Gets the number of properties in the schema, which is the persistent properties from the original class.
             </summary>
            </member>
        <member name="M:Realms.Schema.ObjectSchema.TryFindProperty(System.String,Realms.Schema.Property@)">
             <summary>
             Looks for a Property by Name. Failure to find means it is not regarded as a property to persist in a Realm.
             </summary>
             <returns><c>true</c>, if a property was found matching Name, <c>false</c> otherwise.</returns>
             <param name="name">Name of the Property to match exactly.</param>
             <param name="property">Property returned only if found matching Name.</param>
            </member>
        <member name="M:Realms.Schema.ObjectSchema.GetEnumerator">
             <summary>
             Property enumerator factory for an iterator to be called explicitly or used in a foreach loop.
             </summary>
             <returns>An enumerator over the list of Property instances described in the schema.</returns>
            </member>
        <member name="M:Realms.Schema.ObjectSchema.FromType(System.Type)">
             <summary>
             Creates a schema describing a RealmObject subclass in terms of its persisted members.
             </summary>
             <exception cref="T:System.ArgumentException">Thrown if no class Type is provided or if it doesn't descend directly from RealmObject.</exception>
             <returns>An ObjectSchema describing the specified Type.</returns>
             <param name="type">Type of a RealmObject descendant for which you want a schema.</param>
            </member>
        <member name="T:Realms.Schema.ObjectSchema.Builder">
             <summary>
             Helper class used to construct an ObjectSchema.
             </summary>
            </member>
        <member name="P:Realms.Schema.ObjectSchema.Builder.Name">
             <summary>
             Gets the name of the class to be returned in the ObjectSchema.
             </summary>
            </member>
        <member name="M:Realms.Schema.ObjectSchema.Builder.#ctor(System.String)">
             <summary>
             Initializes a new instance of the <see cref="T:Realms.Schema.ObjectSchema.Builder" /> class.
             </summary>
             <param name="name">The name of the class that will be built.</param>
            </member>
        <member name="M:Realms.Schema.ObjectSchema.Builder.Build">
             <summary>
             Build the ObjectSchema to include all Property instances added to this Builder.
             </summary>
             <exception cref="T:System.InvalidOperationException">Thrown if the Builder is empty.</exception>
             <returns>A completed ObjectSchema, suitable for composing a RealmSchema that will be used to create a new Realm.</returns>
            </member>
        <member name="T:Realms.RealmInvalidObjectException">
             <summary>
             An exception, thrown when the object is no longer managed by the Realm.
             </summary>
            </member>
        <member name="T:Realms.RealmClosedException">
             <summary>
             An exception thrown when trying to invoke members of a closed Realm.
             </summary>
            </member>
        <member name="T:Realms.RealmClassLacksPrimaryKeyException">
             <summary>
             An exception thrown when trying to lookup an object by primary key, when the object doesn't have PrimaryKey specified.
             </summary>
            </member>
        <member name="T:Realms.RealmDuplicatePrimaryKeyValueException">
             <summary>
             An exception thrown when an object with the same primary key has already been added.
             </summary>
            </member>
        <member name="T:Realms.Migration">
             <summary>
             This class is given to you when you migrate your database from one version to another.
             It contains two properties: <c>OldRealm</c> and <c>NewRealm</c>.
             The <c>NewRealm</c> is the one you should make sure is up to date. It will contain
             models corresponding to the configuration you've supplied.
             You can read from the old realm and access properties that have been removed from
             the classes by using the dynamic API. See more in the migrations section in the documentation.
             </summary>
            </member>
        <member name="P:Realms.Migration.OldRealm">
             <summary>
             Gets the realm as it was before migrating. Use the dynamic API to access it.
             </summary>
            </member>
        <member name="P:Realms.Migration.NewRealm">
             <summary>
             Gets the realm that you should modify and make sure is up to date.
             </summary>
            </member>
        <member name="T:Realms.ErrorEventArgs">
             <summary>
             Provides error information for the <see cref="E:Realms.Realm.Error" /> event.
             </summary>
            </member>
        <member name="P:Realms.ErrorEventArgs.Exception">
             <summary>
             Gets the <see cref="T:System.Exception" /> that represents the error that occurred.
             </summary>
            </member>
        <member name="M:Realms.ErrorEventArgs.#ctor(System.Exception)">
             <summary>
             Initializes a new instance of the <see cref="T:Realms.ErrorEventArgs" /> class.
             </summary>
             <param name="ex">An <see cref="T:System.Exception" /> that represents the error that occurred.</param>
            </member>
        <member name="T:Realms.RealmConfiguration">
             <summary>
             Realm configuration specifying settings that affect the Realm's behavior.
             </summary>
             <remarks>
             Its main role is generating a canonical path from whatever absolute, relative subdirectory or just filename the user supplies.
             </remarks>
            </member>
        <member name="T:Realms.RealmConfiguration.MigrationCallbackDelegate">
             <summary>
             In order to handle manual migrations, you need to supply one of these to your <c>RealmConfiguration</c>.
             It will be called with a <c>Migration</c> instance containing the pre- and the post-migration realm.
             You should make sure that the <c>NewRealm</c> property on it contains a database that is up
             to date when returning.
             The <c>oldSchemaVersion</c> parameter will tell you which version the user is migrating *from*.
             They should always be migrating to the current version.
             </summary>
             <param name="migration">The <see cref="T:Realms.Migration" /> instance, containing information about the old and the new realm.</param>
             <param name="oldSchemaVersion">An unsigned long value indicating the schema version of the old realm.</param>
            </member>
        <member name="P:Realms.RealmConfiguration.ShouldDeleteIfMigrationNeeded">
             <summary>
             Gets or sets a value indicating whether the database will be deleted if the schema mismatches the one in the code. Use this when debugging and developing your app but never release it with this flag set to <c>true</c>.
             </summary>
            </member>
        <member name="P:Realms.RealmConfiguration.IsReadOnly">
             <summary>
             Gets or sets a value indicating whether a Realm is opened as readonly. This allows opening it from locked locations such as resources, bundled with an application.
             </summary>
            </member>
        <member name="P:Realms.RealmConfiguration.MigrationCallback">
             <summary>
             Gets or sets the migration callback.
             </summary>
            </member>
        <member name="P:Realms.RealmConfiguration.DefaultConfiguration">
             <summary>
             Gets or sets the configuration that is used when creating a new Realm without specifying a configuration.
             </summary>
            </member>
        <member name="M:Realms.RealmConfiguration.#ctor(System.String)">
             <summary>
             Initializes a new instance of the <see cref="T:Realms.RealmConfiguration" /> class.
             </summary>
             <param name="optionalPath">Path to the realm, must be a valid full path for the current platform, relative subdirectory, or just filename.</param>
            </member>
        <member name="M:Realms.RealmConfiguration.ConfigWithPath(System.String)">
             <summary>
             Clone method allowing you to override or customize the current path.
             </summary>
             <returns>An object with a fully-specified, canonical path.</returns>
             <param name="newConfigPath">Path to the realm, must be a valid full path for the current platform, relative subdirectory, or just filename.</param>
            </member>
        <member name="T:Realms.PrimaryKeyAttribute">
             <summary>
             An attribute that indicates the primary key property. It allows quick lookup of objects and enforces uniqueness of the values stored. It may only be applied to a single property in a class.
             </summary>
             <remarks>
             Only char, integral types, and strings can be used as primary keys.
             Once an object with a Primary Key has been added to the Realm, that property may not be changed.
             </remarks>
            </member>
        <member name="M:Realms.PrimaryKeyAttribute.#ctor">
             <summary>
             Initializes a new instance of the <see cref="T:Realms.PrimaryKeyAttribute" /> class.
             </summary>
            </member>
        <member name="T:Realms.PreserveAttribute">
             <summary>
             Prevents the Xamarin managed linker from linking the target.
             </summary>
            </member>
        <member name="F:Realms.PreserveAttribute.AllMembers">
             <summary>
             When used on a class rather than a property, ensures that all members of this type are preserved.
             </summary>
            </member>
        <member name="F:Realms.PreserveAttribute.Conditional">
             <summary>
             Flags the method as a method to preserve during linking if the container class is pulled in.
             </summary>
            </member>
        <member name="M:Realms.PreserveAttribute.#ctor(System.Boolean,System.Boolean)">
             <summary>
             Initializes a new instance of the <see cref="T:Realms.PreserveAttribute" /> class.
             </summary>
             <param name="allMembers">If set to <c>true</c> all members will be preserved.</param>
             <param name="conditional">If set to <c>true</c>, the method will only be preserved if the container class is preserved.</param>
            </member>
        <member name="M:Realms.PreserveAttribute.#ctor">
             <summary>
             Initializes a new instance of the <see cref="T:Realms.PreserveAttribute" /> class.
             </summary>
            </member>
        <member name="T:Realms.IndexedAttribute">
             <summary>
             An attribute that indicates an indexed property. Indexed properties slow down insertions, but can greatly speed up queries.
             </summary>
            </member>
        <member name="M:Realms.IndexedAttribute.#ctor">
             <summary>
             Initializes a new instance of the <see cref="T:Realms.IndexedAttribute" /> class.
             </summary>
            </member>
        <member name="T:Realms.IgnoredAttribute">
             <summary>
             An attribute that indicates an ignored property. Ignored properties will not be persisted in the Realm.
             </summary>
            </member>
        <member name="M:Realms.IgnoredAttribute.#ctor">
             <summary>
             Initializes a new instance of the <see cref="T:Realms.IgnoredAttribute" /> class.
             </summary>
            </member>
        <member name="T:Realms.RequiredAttribute">
             <summary>
             An attribute that indicates a required property. When persisting, the Realm will validate that the value of the property is not null.
             </summary>
            </member>
        <member name="M:Realms.RequiredAttribute.#ctor">
             <summary>
             Initializes a new instance of the <see cref="T:Realms.RequiredAttribute" /> class.
             </summary>
            </member>
        <member name="T:Realms.MapToAttribute">
             <summary>
             An attribute that indicates that a property should be persisted under a different name.
             </summary>
             <remarks>
             This is useful when opening a Realm across different bindings where code style conventions might differ.
             </remarks>
            </member>
        <member name="P:Realms.MapToAttribute.Mapping">
             <summary>
             Gets or sets the name of the property in the database.
             </summary>
            </member>
        <member name="M:Realms.MapToAttribute.#ctor(System.String)">
             <summary>
             Initializes a new instance of the <see cref="T:Realms.MapToAttribute" /> class.
             </summary>
             <param name="mapping">The name of the property in the database.</param>
            </member>
        <member name="T:Realms.WovenAttribute">
             <summary>
             An attribute that indicates that a class has been woven. It is applied automatically by the RealmWeaver and should not be used manually.
             </summary>
            </member>
        <member name="M:Realms.WovenAttribute.#ctor(System.Type)">
             <summary>
             Initializes a new instance of the <see cref="T:Realms.WovenAttribute" /> class.
             </summary>
             <param name="helperType">The type of the generated RealmObjectHelper for that class.</param>
            </member>
        <member name="T:Realms.WovenPropertyAttribute">
             <summary>
             An attribute that indicates that a property has been woven. It is applied automatically by the RealmWeaver and should not be used manually.
             </summary>
            </member>
        <member name="T:Realms.ExplicitAttribute">
             <summary>
             Do not implicitly add the type decorated by this attribute to a Realm's schema unless it has been explicitly set.
             </summary>
            </member>
        <member name="T:Realms.BacklinkAttribute">
             <summary>
             An attribute that indicates that the property it decorates is the inverse end of a relationship.
             </summary>
            </member>
        <member name="M:Realms.BacklinkAttribute.#ctor(System.String)">
             <summary>
             Initializes a new instance of the <see cref="T:Realms.BacklinkAttribute" /> class.
             </summary>
             <param name="property">The property that is on the other end of the relationship.</param>
            </member>
    </members>
</doc>
